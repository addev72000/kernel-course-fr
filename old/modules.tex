% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Copyright 2010 Jérôme Pouiller <jezz@sysmic.org>
%

\part{Modules noyau}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents[currentpart]
\end{frame}



\section{Notre premier device}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize}
  \item Voie classique pour un driver pour communiquer avec le noyau
  \item Major, Minor
    \begin{lstlisting}
target% mknod my_chardev c <major> <minor>
    \end{lstlisting}
  \item Communication en écrivant/lisant des données
    \begin{lstlisting}
target% insmod my_chardev.ko
target% echo toto >  my_dhardev
target% cat my_chardev
    \end{lstlisting}
  \item Possibilité de faire un peu de configuration par les ioctl
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  Exo: Faire un pipe avec un buffer:
  \begin{lstlisting}
target% insmod my_chardev.ko
target% echo toto >  my_dhardev
target% cat my_chardev
toto
  \end{lstlisting}
  \begin{itemize}
  \item \verb+copy_to_user+, \verb+copy_from_user+
  \item \verb+kcalloc+, \verb+kfree+
  \item \verb+register_chrdev+, \verb+unregister_chrdev_region+
  \item   \verb+mutex_lock+,  \verb+mutex_unlock+,  \verb+mutex_init+,
    \verb+mutex_destroy+
  \item \verb+memmove+
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
   Vérifions votre comportement:
   \begin{lstlisting}
target% insmod my_chrdev.ko
target% mknod my_chrdev c 251 0
target$ for i in {1..64}; echo "$i " > my_chrdev
target$ cat my_chrdev
target% rmmod my_chrdev
target% insmod my_chrdev.ko buf_size=2
target$ echo foo > /dev/my_chrdev
target$ cat /dev/my_chrdev
target% rmmod my_chrdev
target% insmod my_chrdev.ko buf_size=-1
    \end{lstlisting} % $
\end{frame}
 
% \begin{frame}{Les ioctls}
%   C'est un appel système qui permet de faire passer une structure
%   quelconque à un device.\\
%   Pour appeller un ioctl, il faut un device, le numéro de l'IOCTL et
%   l'arguments.\\
%   Les  numéro d'IOCTL  se  décode ainsi  (attention,  ca n'est  qu'une
%   norme, et elle a ses exeception, principalement powerpc):
% %   \begin{lstlisting}
% %  bits    meaning
% %  31-30  00 - no parameters: uses _IO macro
% %         10 - read: _IOR
% %         01 - write: _IOW
% %         11 - read/write: _IOWR
% % 
% %  29-16  size of arguments
% % 
% %  15-8   ascii character supposedly
% %         unique to each driver
% % 
% %  7-0    function #
% % 
% % 
% % So for example 0x82187201 is a read with arg length of 0x218,
% % character 'r' function 1. Grepping the source reveals this is:
% % Les ioctl doivent être unique par device. Mais on préfère qu'il soit unique
% % sur tout le système.
% % 
% % Les macro _IOR, _IOW, _IORW et _IO nous aident:
% % #define CHANGE_BUF_SZ _IOR(42, 1, int)
% %    \end{lstlisting}

% Aller plus loin: \file{device.h}: Implémentation d'un device complet.
% \end{frame}

\begin{frame}[fragile=singleslide]{Obtenir de la documentation}
  \begin{lstlisting}
host$ make mandocs
host% make installmandocs
  \end{lstlisting}  % $
  \begin{itemize}
    \item Paquet linux-doc: \file{/usr/share/doc/linux-doc/html/kernel-api}
    \item Pas de paquet pour ces pages de man 
    \item ou pages de man sur \url{http://tfm.cz}
  \end{itemize}
\end{frame}

% TODO: Faire un device usb-gadget/hid 

% Note
% echo none > /sys/devices/platform//leds-gpio/leds/user_led/trigger
% echo 255 > /sys/devices/platform//leds-gpio/leds/user_led/brightness

