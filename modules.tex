%
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2012-03-13 00:09:08+01:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

\part{Les modules}
\section{Création de modules}

  % insmod/rmmmod
  % modprobe
  % Compiler à l'extérieur du kernel
  % Les Macro
  %   Les paramètres
  %   /sys/**/param
  % Les licences
\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  \lstinputlisting[language=c,firstline=16]{modules/my_module1.c}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques macros de base}
  Ces macros  permettent de placer  des informations sur  des symboles
  particulier dans module;
  \begin{itemize} 
  \item Déclare  la fonction  à apeller lors  du chargement  du module
  (traditionnellement module\texttt{\_init})
    \begin{lstlisting} 
module_init
    \end{lstlisting} 
  \item Déclare la fonction à  appeller lors du déchargement du module
  (traditionnellement module\texttt{\_exit})
    \begin{lstlisting} 
module_exit
    \end{lstlisting} 
  \item Déclare un auteur du fichier. Peut apparaitre plusieurs fois.
    \begin{lstlisting}
MODULE_AUTHOR
    \end{lstlisting}
  \end{itemize}
\end{frame}
\begin{frame}[fragile=singleslide]{Quelques macros de base}
  \begin{itemize} 
  \item Description du modules
    \begin{lstlisting}
MODULE_DESCRIPTION
    \end{lstlisting}
  \item Version du module
    \begin{lstlisting}
MODULE_VERSION
    \end{lstlisting}
  \item Rendre un symbole visible par les autres modules.  Il sera alors
    pris en compte dans le calcul des dépendances de symboles.
    \begin{lstlisting}
EXPORT_SYMBOL(symbol)
    \end{lstlisting} 
  \item Idem \cmd{EXPORT\_SYMBOL} mais  ne permet sont utilisation que
    pour les modules GPL
    \begin{lstlisting}
EXPORT_SYMBOL_GPL(symbol)
    \end{lstlisting} 
  \item License. Indispensable
    \begin{lstlisting}
MODULE_LICENSE
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Parlons des licenses}
  Le noyau est sous license GPL. Néanmoins, le débat est ouvert sur la
  possibilité  qu'un module  propriétaire puisse  se linker  avec.  Le
  débat n'est pas  tranché. Le noyau laisse la  possibilité à l'auteur
  d'exporter   ses   modules   avec   \verb+EXPORT_SYMBOL+   ou   avec
  \verb+EXPORT_SYMBOL_GPL+.
  \\[2ex]
  Si vous développez un module Propriétaire, vous n'aurez pas accès à
  toute l'API du noyau (environ 90\% seulement).
  \\[2ex]
  Il est néanmoins possible de contourner le problème en utilisant un
  module intermédiaire comme proxy logiciel.
  \\[2ex]
  De plus,  un module  propriétaire ne doit  pas compiler  en statique
  avec  le noyau  (le résultat  est alors  considéré comme  un travail
  dérivé du noyau). Il doit rester sous la forme d'un module.
\end{frame}
\begin{frame}[fragile=singleslide]{Les licences}
  En  remplissant  correctement  la  macro  \verb+MODULE_LICENCE+,  le
  système   de  compilation  du   noyau  empêchera   les  compilations
  illégales.   \verb+MODULE_LICENCE+ peut  prendre  plusieurs valeurs:
  GPL, GPL v2, GPL and additionnal rights, Dual MIT/GPL, Dual BSD/GPL,
  Dual  MPL/GPL.   Toutes les  autre  valeurs  sont considérées  comme
  propriétaire.

  \file{/proc/sys/kernel/tainted} (ou  \cmd{uname -a}) indique  si des
  modules propriétaires sont chargé.
  
  Quels conséquences?
  \begin{itemize} 
  \item Pas de support de la part de la communauté
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Headers}
  Il  n'est  pas   possible  pour  le  noyau  de   compiler  avec  des
  bibliothèques  extérieur.  En  particulier  avec la  libc. Tous  les
  headers habituels sont donc inaccessible dans le noyau.

  Les headers ``publiques'' sont dans \verb+include/+. On retiendra en
  particulier:       \file{linux/module.h},       \file{linux/init.h},
  \file{linux/kernel.h} indispensables pour compiler un module.

\end{frame} 

\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  \lstinputlisting[language=c,lastline=14]{modules/my_module1.c}
\end{frame}


\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  Makefile:
  \begin{lstlisting}
obj-m := my_module.o  
  \end{lstlisting}
  Puis, on appelle:
  \begin{lstlisting}
host$ KDIR=/lib/modules/$(uname -r)/build
host$ make -C $KDIR ARCH=arm SUBDIRS=$(pwd) modules
  \end{lstlisting} % $
  Pour améliorer le processus, on ajoute ces lignes dans le Makefile:
  \begin{lstlisting}
KDIR ?= /lib/modules/$(shell uname -r)/build

default:
        $(MAKE) -C $(KDIR) SUBDIRS=$(shell pwd) modules
  \end{lstlisting}
  et on appelle
  \begin{lstlisting}
host$ make ARCH=arm KDIR=../linux-2.6/usb-a9260 
  \end{lstlisting} % $
\end{frame}

  % Compiler à l'interieur du kernel
  % Fonctionnement de Kconfig
\begin{frame}[fragile=singleslide]{Compilation avec Kmake}
  Makefile:
  \begin{lstlisting}
obj-$(MY_COMPILE_OPTION) := my_module.o  
  \end{lstlisting} % $
  \lstinline+$(MY_COMPILE_OPTION)+ sera remplacé par :
  \begin{itemize}
  \item ø: Non compilé
  \item m: compilé en module
  \item y: compilé en statique
  \end{itemize}
  Kconfig
  \lstinputlisting[langage=]{modules/Kconfig}
  \note[item]{detailler les différentes options de Kconfig}
\end{frame}

\begin{frame}[fragile=singleslide]{Gérer les modules}
  \begin{itemize} 
  \item Avoir des informations sur le module
    \begin{lstlisting}
host$ modinfo my_module.ko
    \end{lstlisting} %$
  \item Charger un module
    \begin{lstlisting}
target% insmod my_module.ko
    \end{lstlisting} %$
  \item Décharger un module
    \begin{lstlisting}
target% rmmod my_module
    \end{lstlisting}%$
  \item Afficher le buffer de log du kernel
    \begin{lstlisting}
target$ dmesg
    \end{lstlisting} %$
  \item Charger/décharger un module correctement installé/indexé
    \begin{lstlisting}
target% modprobe my_module
target% modprobe -r my_module
    \end{lstlisting} %$
  \item Mettre à jour le fichier de dépendance
    \begin{lstlisting} 
target% depmod
    \end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Paramètres}
  Il est possible de passer des paramètres aux modules:
  \begin{lstlisting}
target$ modinfo my_module.ko 
target% insmod my_module.ko param=2  
  \end{lstlisting} %$ 
  Il est possible de passer le paramètre au boot avec \c{my_module.param=2}
\\[2ex]
  Nous   devons  déclarer   le  paramètre   à  l'aide   de   la  macro
  \c{module_param}.
  \begin{lstlisting}[language=c]
module_param(name, type, perm);
  \end{lstlisting} 
  Prend en paramètres:
  \begin{itemize} 
  \item \cmd{name}: Nom de la variable utilisée comme paramètre
  \item  \cmd{type}:  Type   du  paramètre  (\cmd{bool},  \cmd{charp},
    \cmd{byte},  \cmd{short},   \cmd{ushort},  \cmd{int},  \cmd{uint},
    \cmd{long}, \cmd{ulong}) (remarquez que  ca ne correspond pas tout
    à  fait   aux  types   C.  Particulièrement  pour   \cmd{bool}  et
    \cmd{charp})
  \item        \cmd{perm}:        Permissions        du        fichier
    \file{/sys/module/<module>/parameters/<param>}.    (utiliser   les
    macros de \file{linux/stat.h}). Si 0, le fichier n'apparait pas.
  \end{itemize}
  La paramètre doit évidement être alloué:
  \begin{lstlisting}[language=c]
static int param = 0;
  \end{lstlisting} 
  Il est fortement recommandé de documenter le paramètre
  \begin{lstlisting}[language=c]
MODULE_PARM_DESC(param, "Display this value at loading and unloading");
  \end{lstlisting} 
Référence : \file{linux/moduleparam.h}

\end{frame}

\begin{frame}[fragile=singleslide]{\texttt{/sys}}
  Etudions \file{/sys}
  \begin{itemize}
  \item                       \file{/sys/module/my\_module/parameters}:
    paramètres. Modifiable si déclaré modifiables
  \item \file{/sys/module/my\_module/sections}:  des info sur  la zone
    de chargement
  \end{itemize}
\end{frame}

  %   Le coding style
  %   La documentation
  %   Gestion des erreurs:
  %       -EAGAIN, etc...
  %       goto
  %        errno.h
\subsection{Programmer}
\begin{frame}[fragile=singleslide]{Le Coding Style}
  \begin{itemize} 
  \item On  ne doit pas avoir besoin  d'utiliser l'ascenseur (vertical
    ou horizontal)  pour lire  une fonction (bref:  80 colonne  et pas
    trop de lignes par fonctions)
  \item Indentation à la tabulation
  \item ... et une tabulation fait 8 espaces
  \item Si  l'indentation vous empêche d'écrire  votre fonction, c'est
    que celle-ci possède trop de niveau d'imbrication
  \item Mettre  au propre  les tabulations et  vérifier la  taille des
    lignes:
    \begin{lstlisting} 
host$ scripts/cleanfile my_module.c
    \end{lstlisting} %$
  \item Incolade sur la même ligne que les bloc
  \item ... sauf pour les fonctions
  \item  Pour indenter correctement votre code
    \begin{lstlisting}
host$ apt-get indent
host$ scripts/Lindent my_module.c
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{CodingStyle}
  \begin{itemize} 
  \item Les variable locale doivent être courtes
  \item Pas de CamelCase
  \item Si vous n'arriver pas à  vous y retrouver, c'est que vous avez
    trop de variables locales
  \item  Il faut  préserver  la  propreté de  l'espace  de nommage  en
    préfixant  par statique  tout ce  qui  ne doit  pas être  expporté
    (fonctions, variables)
  \item Référence: \file{Documentation/CodingStyle}
  \end{itemize} 
\end{frame} 

 % A couper en deux: une  partie au niveau de "arboresence de sources"
 % et une partie au niveau de l'API
  % Documentation
  % API non stable
  % generer
  %    pages de man
  %    html
  % sur le web
  %    kernel/doc
  %    lxr.linux.no
  % par mail
  %   connaitre avoir l'auteur avec AUTOR
  %   connaitre l'auteur avec git blame
\begin{frame}[fragile=singleslide]{La documentation}
  \begin{itemize}
  \item Le noyau n'est pas un modèle de documentation
  \item En  revanche, le système de  développement facilite énormément
    la recherche d'informations
  \item  Le noyau utilise  un script  perl appellé  \c{kernel-doc}. Ce
    script parcours le code à la recherche de syntaxe du même type que
    doxygen.  (Référence: \file{Documentation/kernel-docs.txt})
  \item  Un  commentaire ne  doit  pas ce  substituer  à  un code  pas
    illisible.  Préférez   réécrire  le  code   plutôt  qu'ajouter  un
    commentaire.
  \item Les fonction exportée doivent être préfixée par un commentaire
    la   décrivant.    Ce  commentaire   ne   doit  surtout   explique
    \emph{comment}  la  fonction marche.   Le  commentaire indique  le
    \emph{quoi},  mais  surtout   le  \emph{pourquoi}  cette  fonction
    existe.
  \item Ces  commentaires sont  placée avant la  \emph{définition} des
    fonctions.  Les  fonction du noyau  sont souvent définie  dans les
    headers.  Du  coup, les commentaires sont parfois  dans le fichier
    \file{.c} et parfois dans le fichier \file{.h}
  \item  Les commentaires  expliquant le  fonctionnement  général d'un
    framework  doivent être  écrit sous  la forme  d'une documentation
    d'architecture et placée dans \file{Documentation/}
  \item Référence: \file{Documentation/CodingStyle}
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{Trouver de la documentation}
  \begin{itemize} 
  \item Dans \file{Documentation} (en utilisant \cmd{grep})
  \item La cible \c{htmldocs}  permet de compiler les documentation au
    format Docbook (\file{Documentation/DocBook})
  \item ... en particulier  \emph{Linux Device Drivers} et \emph{Linux
      Device  Drivers}. Toutefois, ces  compilations sont  loin d'être
    exaustives
  \item  La cible  \c{mandocs}  permet d'extraire  les différente  API
    invoquée dans les DocBook sous forme de pages de man.
  \item    \url{http://kernel.org/doc}     regroupe    les    diverses
    documentations en ligne
  \item Dans les commentaire du noyau (fichiers .c ou .h)
  \item  \url{http://lxr.linux.no} offre  une interface  permettant de
    rapidement  chercher des  symboles  et naviguer  dans  le code  du
    noyau.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Trouver de l'aide}
Demander de l'aide à la communauté
    \begin{itemize}
    \item Le  fichier MAINTAINERS contient la liste  des mainteneur de
      chaque sous-système
    \item Les entrées commencant par \texttt{L:} indique des mailing
      list
    \item Notons \email{linux-newbie@vger.kernel.org}
    \item MAINTAINERS  liste aussi les sites  officiel, les fichiers
      de documentation, etc...   pour les différents sous-projets du
      noyau
    \item \c{git blame} permet de savoir qui a modifier la fonctions
      ou les  lignes qui nous  intéresse. Cela permet  de s'oreinter
      vers le bon groupe
    \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{L'API non-stable}
  \begin{itemize} 
  \item  L'API   non-stable  ne   facilite  pas  la   maintenance  des
    documentations
  \item  De même,  la maintenance  des modules  hors du  noyau demande
    beaucoup d'efforts
  \item  C'est  encore pire  de  maintenir  un  module pour  plusieurs
    versions (driver nvidia par exemple)
  \item En  revanche, l'API non  stable permet des  développement plus
    agiles)
  \item  Lors  qu'un développeur  modifie  une  API,  il doit  patcher
    l'ensemble des driver utilisant l'ancienne API.
  \item  On préfère  souvent  laisser l'ancienne  et  la nouvelle  API
    cohabiter en demandant au mainteners de migrer vers la nouvelle
  \item Il n'y  a pas de raisons de maintenir  un driver à l'extérieur
    du noyau, sauf les problèmes de licence
  \item  Il peut être  couteux en  temps d'intégré  un module  dans le
    mainsteam. Les  mainteneurs vous demanderons  surement de corriger
    beaucoup de chose.
  \item Il faut  compter 2 à 4 fois le  temps de développement initial
    pour intégrer un module dans le mainstream
  \item Une fois que votre module  est intégré dans le mainstream et a
    passé  la phase  de  staging, il  sera  théoriquement maintenu  et
    supporté pour toujours.
  \item Référence \c{Documentation/stable_api_nonsense.txt}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Gestion des erreurs}
  \begin{itemize} 
  \item La plupart des fonctions retournant des \c{int} retournent une
    valeur négative en cas d'erreur
  \item Les  valeurs retournée correspondent aux  inverses des erreurs
    Posix  définis dans  \file{errno.h} (ie:  \c{-EAGAIN}). Référence:
    \emph{errno(3)}
  \item  Les  fonctions  renvoyant des  pointeurs  peuvent
    retourner NULL ou des valeurs spéciale en cas d'erreur
  \item Utiliser les macro \c{PTR_ERR}, \c{ERR_PTR} et \c{IS_ERR}
  \item Le segfault n'existe pas  dans le noyau.  Par conséquent, vous
    n'avez pas de garde fou (bon, il  y a bien les Oops, mais ca n'est
    pas garanti)
  \item Référence \file{linux/err.h}
  \item Vous devez systèmatiquement gérer les erreur retourner par les
    sous-fonctions  même  si  il  vous semble  impossible  qu'elle  se
    produise.
  \item Certaines pannes  matérielles peuvent amener des comportements
    qui paraissent  impossibles. Facilité le  travaille des débuggueur
    en détectant ce type d'erreur le plus tôt possible
  \end{itemize}
\end{frame}
\begin{frame}[fragile=singleslide]{Gérer les erreurs}
  \begin{itemize} 
  \item Lorsque vous gérez  une erreur, vous devez \emph{défaire} tout
    ce qui à déjà été fait
  \item Une manière commnue  de gérer les erreur d'initialisation dans
    le noyau est d'utiliser \c{goto}:
    \begin{lstlisting}
ptr = kmalloc(sizeof(device_t));
if (!ptr) {
    ret = -ENOMEM
    goto err_alloc;
}
dev = init(&ptr);
if (dev) {
    ret = -EIO
    goto err_init;
}
return 0;

err_init:
    free(ptr);
err_alloc:
    return ret;
    \end{lstlisting} 
  \end{itemize} 
\end{frame} 



\section{Notre premier device}


\note{Il s'agit ici d'un gros morceau, mais il est traité en qqs slides}
\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize}
  \item Voie classique pour un driver pour communiquer avec le noyau
  \item Major, Minor
    \begin{lstlisting}
target% mknod my_chardev c <major> <minor>
    \end{lstlisting}
  \item Communication en écrivant/lisant des données
    \begin{lstlisting}
target% insmod my_chardev.ko
target% echo toto > my_chardev
target% cat my_chardev
    \end{lstlisting}
  \item Possibilité de faire un peu de configuration par les ioctl
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  Exo: Faire un pipe avec un buffer:
  \begin{lstlisting}
target% insmod my_chardev.ko
target% echo toto > my_dhardev
target% cat my_chardev
toto
  \end{lstlisting}
%% TODO: Présenter les différentes fonction ci-dessous
\note{Motrer le code, décrire le contenu}
  \begin{itemize}
  \item \verb+copy_to_user+, \verb+copy_from_user+
  \item \verb+kcalloc+, \verb+kfree+
  \item \verb+register_chrdev+, \verb+unregister_chrdev_region+
  \item   \verb+mutex_lock+,  \verb+mutex_unlock+,  \verb+mutex_init+,
    \verb+mutex_destroy+
  \item \verb+memmove+
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
   Vérifions votre comportement:
   \begin{lstlisting}
target% insmod my_chrdev.ko
target% mknod my_chrdev c 251 0
target$ for i in {1..64}; echo "$i " > my_chrdev
target$ cat my_chrdev
target% rmmod my_chrdev
target% insmod my_chrdev.ko buf_size=2
target$ echo foo > /dev/my_chrdev
target$ cat /dev/my_chrdev
target% rmmod my_chrdev
target% insmod my_chrdev.ko buf_size=-1
    \end{lstlisting} % $
\end{frame}
 
% \begin{frame}{Les ioctls}
%   C'est un appel système qui permet de faire passer une structure
%   quelconque à un device.\\
%   Pour appeller un ioctl, il faut un device, le numéro de l'IOCTL et
%   l'arguments.\\
%   Les  numéro d'IOCTL  se  décode ainsi  (attention,  ca n'est  qu'une
%   norme, et elle a ses exeception, principalement powerpc):
% %   \begin{lstlisting}
% %  bits    meaning
% %  31-30  00 - no parameters: uses _IO macro
% %         10 - read: _IOR
% %         01 - write: _IOW
% %         11 - read/write: _IOWR
% % 
% %  29-16  size of arguments
% % 
% %  15-8   ascii character supposedly
% %         unique to each driver
% % 
% %  7-0    function #
% % 
% % 
% % So for example 0x82187201 is a read with arg length of 0x218,
% % character 'r' function 1. Grepping the source reveals this is:
% % Les ioctl doivent être unique par device. Mais on préfère qu'il soit unique
% % sur tout le système.
% % 
% % Les macro _IOR, _IOW, _IORW et _IO nous aident:
% % #define CHANGE_BUF_SZ _IOR(42, 1, int)
% %    \end{lstlisting}

% Aller plus loin: \file{device.h}: Implémentation d'un device complet.
% \end{frame}


  % Programmer
  %   la libc
  %   Big Endian/Little Endian
  %   Preemption (nous y reviendrons)
  %   Les espace mémoire : copy_to_user copy_from_user
  %   Segfault: n'existe pas
  %    Les types: 
  %      u8...u64, s8...s64
  %      __le16..__le64 __be16..__be64
  %      void* et unsigned long et phys_addr_t
 %       linux/types.h
  %      bool mais pas utilisé
  %      Les types de la libc, utilisé pour communique avec l'espace utilisateur: pid_t, uid_t, etc...
  % Les fichier device
  %   mknod
  %   devtmpfs
  % Les appels systèmes
  % Les structure de pointeurs sur fonctions



