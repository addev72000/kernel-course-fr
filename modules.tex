%
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Created: 2012-03-13 00:09:08+01:00
% Main authors:
%     - Jérôme Pouiller <jezz@sysmic.org>
%

\part{Les modules}

\begin{frame}
  \partpage
\end{frame}

\begin{frame}
  \tableofcontents[currentpart]
\end{frame}

\section{Création de modules}

  % insmod/rmmmod
  % modprobe
  % Compiler à l'extérieur du kernel
  % Les Macro
  %   Les paramètres
  %   /sys/**/param
  % Les licences
\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  Un template de module:
  \lstinputlisting[language=c,firstline=16]{modules/my_module1.c}
\end{frame}

\begin{frame}[fragile=singleslide]{Quelques macros de base}
  Ces macros  permettent de placer  des informations sur  des symboles
  particulier dans module;
  \begin{itemize} 
  \item Déclare  la fonction  à apeller lors  du chargement  du module
  (traditionnellement module\texttt{\_init})
    \begin{lstlisting} 
module_init
    \end{lstlisting} 
  \item Déclare la fonction à  appeller lors du déchargement du module
  (traditionnellement module\texttt{\_exit})
    \begin{lstlisting} 
module_exit
    \end{lstlisting} 
  \item Déclare un auteur du fichier. Peut apparaitre plusieurs fois.
    \begin{lstlisting}
MODULE_AUTHOR
    \end{lstlisting}
  \end{itemize}
\end{frame}
\begin{frame}[fragile=singleslide]{Quelques macros de base}
  \begin{itemize} 
  \item Description du modules
    \begin{lstlisting}
MODULE_DESCRIPTION
    \end{lstlisting}
  \item Version du module
    \begin{lstlisting}
MODULE_VERSION
    \end{lstlisting}
  \item Rendre un symbole visible par les autres modules.  Il sera alors
    pris en compte dans le calcul des dépendances de symboles.
    \begin{lstlisting}
EXPORT_SYMBOL(symbol)
    \end{lstlisting} 
  \item Idem \cmd{EXPORT\_SYMBOL} mais  ne permet sont utilisation que
    pour les modules GPL
    \begin{lstlisting}
EXPORT_SYMBOL_GPL(symbol)
    \end{lstlisting} 
  \item License. Indispensable
    \begin{lstlisting}
MODULE_LICENSE
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Parlons des licenses}
  Le noyau est sous license GPL. Néanmoins, le débat est ouvert sur la
  possibilité  qu'un module  propriétaire puisse  se linker  avec.  Le
  débat n'est pas  tranché. Le noyau laisse la  possibilité à l'auteur
  d'exporter   ses   modules   avec   \verb+EXPORT_SYMBOL+   ou   avec
  \verb+EXPORT_SYMBOL_GPL+.
  \\[2ex]
  Si vous développez un module Propriétaire, vous n'aurez pas accès à
  toute l'API du noyau (environ 90\% seulement).
  \\[2ex]
  Il est néanmoins possible de contourner le problème en utilisant un
  module intermédiaire comme proxy logiciel.
  \\[2ex]
  De plus,  un module  propriétaire ne doit  pas compiler  en statique
  avec  le noyau  (le résultat  est alors  considéré comme  un travail
  dérivé du noyau). Il doit rester sous la forme d'un module.
\end{frame}

\begin{frame}[fragile=singleslide]{Les licences}
  En  remplissant  correctement  la  macro  \verb+MODULE_LICENCE+,  le
  système   de  compilation  du   noyau  empêchera   les  compilations
  illégales.   \verb+MODULE_LICENCE+ peut  prendre  plusieurs valeurs:
  GPL, GPL v2, GPL and additionnal rights, Dual MIT/GPL, Dual BSD/GPL,
  Dual  MPL/GPL.   Toutes les  autre  valeurs  sont considérées  comme
  propriétaire.

  \file{/proc/sys/kernel/tainted} (ou  \cmd{uname -a}) indique  si des
  modules propriétaires sont chargé.
  
  Quels conséquences?
  \begin{itemize} 
  \item Pas de support de la part de la communauté
  \item Pas de garantie de la qualité du modules
  \item Mauvaise image auprès de la communauté et de clients
  \end{itemize}

  Par  expérience,  les modules  propriétaires  que  l'on croise  dans
  l'embarqué peuvent cacher tout et n'importe quoi.
\end{frame}

\begin{frame}[fragile=singleslide]{Headers}
  Il  n'est  pas   possible  pour  le  noyau  de   compiler  avec  des
  bibliothèques extérieur.  En particulier  avec la \c{libc}. Tous les
  headers habituels sont donc inaccessible dans le noyau.

  Les headers ``publiques'' sont dans \verb+include/+. On retiendra en
  particulier:       \file{linux/module.h},       \file{linux/init.h},
  \file{linux/kernel.h} indispensables pour compiler un module.
\end{frame} 

\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  \lstinputlisting[language=c,lastline=14]{modules/my_module1.c}
\end{frame}


\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  Fichier \c{Makefile} à l'extérieur du noyau:
  \begin{lstlisting}
obj-m := my_module.o  
  \end{lstlisting}
  Puis, on appelle:
  \begin{lstlisting}
host$ KDIR=/lib/modules/$(uname -r)/build
host$ make -C $KDIR ARCH=arm M=$(pwd) modules
  \end{lstlisting} % $
  Il aussi est possible d'appeller les cibles \c{help} et \c{modules_install}
\end{frame}

\begin{frame}[fragile=singleslide]{Les modules noyau}{my\_module}
  Pour améliorer le processus, on ajoute ces lignes dans le \file{Makefile}:
  \begin{lstlisting}
KDIR ?= /lib/modules/$(shell uname -r)/build

default: modules

modules:
        $(MAKE) -C $(KDIR) M=$(shell pwd) modules

modules_install:
        $(MAKE) -C $(KDIR) M=$(shell pwd) modules_install
  \end{lstlisting}
  et on appelle
  \begin{lstlisting}
host$ make ARCH=arm KDIR=../linux-2.6/usb-a9260 
  \end{lstlisting} % $
  Référence: \file{Documentation/kbuild/modules.txt}
\end{frame}

  % Compiler à l'interieur du kernel
  % Fonctionnement de Kconfig
\begin{frame}[fragile=singleslide]{Compilation avec Kmake}
  Fichier \file{Makefile} à l'intérieur de l'arborescence noyau:
  \begin{lstlisting}
obj-$(MY_COMPILE_OPTION) := my_module.o  
  \end{lstlisting} % $
  \lstinline+$(MY_COMPILE_OPTION)+ sera remplacé par :
  \begin{itemize}
  \item ø: Non compilé
  \item m: compilé en module
  \item y: compilé en statique
  \end{itemize}
  Fichier \file{Kconfig}:
  \lstinputlisting[langage=]{modules/Kconfig}
  \note[item]{detailler les différentes options de Kconfig}
  Référence: \file{Documentation/kbuild/makefiles.txt}, \file{Documentation/kbuild/kconfig-language.txt}
\end{frame}

\begin{frame}[fragile=singleslide]{Gérer les modules}
  \begin{itemize} 
  \item Avoir des informations sur le module
    \begin{lstlisting}
host$ modinfo my_module.ko
    \end{lstlisting} %$
  \item Charger un module
    \begin{lstlisting}
target% insmod my_module.ko
    \end{lstlisting} %$
  \item Décharger un module
    \begin{lstlisting}
target% rmmod my_module
    \end{lstlisting}%$
  \item Afficher le buffer de log du kernel (Diagnostic MESsaGes)
    \begin{lstlisting}
target$ dmesg
    \end{lstlisting} %$
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Gérer les modules}
  \begin{itemize} 
  \item Charger/décharger un  module correctement installé/indexé dans
    \c{modules.dep}
    \begin{lstlisting}
target% modprobe my_module
target% modprobe -r my_module
    \end{lstlisting} %$
  \item Mettre à jour le fichier de dépendances
    \begin{lstlisting} 
target% depmod
    \end{lstlisting} %$
  \item Notons que les  modules sont des binaires \emph{elf} standards
    qui peuvent être analysés avec les outils standard:
    \begin{lstlisting}
host$ arm-linux-objdump -t my_module.ko
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Paramètres}
  Il est possible de passer des paramètres aux modules:
  \begin{lstlisting}
target$ modinfo my_module.ko 
target% insmod my_module.ko param=2  
  \end{lstlisting} %$ 
  Il est possible de passer le paramètre au boot avec \c{my_module.param=2}
\end{frame}

\begin{frame}[fragile=singleslide]{Paramètres}
  Nous   devons  déclarer   le  paramètre   à  l'aide   de   la  macro
  \begin{lstlisting}[language=c]
module_param(name, type, perm);
  \end{lstlisting} 
  \begin{itemize} 
  \item \cmd{name}: Nom de la variable utilisée comme paramètre
  \item  \cmd{type}:  Type   du  paramètre  (\cmd{bool},  \cmd{charp},
    \cmd{byte},  \cmd{short},   \cmd{ushort},  \cmd{int},  \cmd{uint},
    \cmd{long}, \cmd{ulong}) (remarquez que  ca ne correspond pas tout
    à  fait   aux  types   C.  Particulièrement  pour   \cmd{bool}  et
    \cmd{charp})
  \item        \cmd{perm}:        Permissions        du        fichier
    \file{/sys/module/<module>/parameters/<param>}.    (utiliser   les
    macros de \file{linux/stat.h}). Si 0, le fichier n'apparait pas.
  \end{itemize}
  La paramètre doit évidement être alloué:
  \begin{lstlisting}[language=c]
static int param = 0;
  \end{lstlisting} 
  Il est fortement recommandé de documenter le paramètre
  \begin{lstlisting}[language=c]
MODULE_PARM_DESC(param, "Useless parameter");
  \end{lstlisting} 
  Référence : \file{linux/moduleparam.h}
\end{frame}

\begin{frame}[fragile=singleslide]{\texttt{/sys}}
  Etudions \file{/sys}
  \begin{itemize}
  \item                       \file{/sys/module/my\_module/parameters}:
    paramètres. Modifiable si déclaré modifiables
  \item \file{/sys/module/my\_module/sections}:  des info sur  la zone
    de chargement
  \end{itemize}
\end{frame}

  %   Le coding style
  %   La documentation
  %   Gestion des erreurs:
  %       -EAGAIN, etc...
  %       goto
  %        errno.h
\subsection{Programmer}
\begin{frame}[fragile=singleslide]{Le Coding Style}
  \begin{itemize} 
  \item On  ne doit pas avoir besoin  d'utiliser l'ascenseur (vertical
    ou horizontal)  pour lire  une fonction (bref:  80 colonne  et pas
    trop de lignes par fonctions)
  \item Indentation à la tabulation
  \item ... et une tabulation fait 8 espaces
  \item Si  l'indentation vous empêche d'écrire  votre fonction, c'est
    que celle-ci possède trop de niveau d'imbrication
  \item Mettre  au propre  les tabulations et  vérifier la  taille des
    lignes:
    \begin{lstlisting} 
host$ scripts/cleanfile my_module.c
    \end{lstlisting} %$
  \item Incolade sur la même ligne que les bloc
  \item ... sauf pour les fonctions
  \item  Pour indenter correctement votre code
    \begin{lstlisting}
host$ apt-get indent
host$ scripts/Lindent my_module.c
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{CodingStyle}
  \begin{itemize} 
  \item Les variable locale doivent être courtes
  \item Pas de CamelCase
  \item Si vous n'arriver pas à  vous y retrouver, c'est que vous avez
    trop de variables locales
  \item  Il faut  préserver  la  propreté de  l'espace  de nommage  en
    préfixant  par statique  tout ce  qui  ne doit  pas être  expporté
    (fonctions, variables)
  \item Référence: \file{Documentation/CodingStyle}
  \end{itemize} 
\end{frame} 

 % A couper en deux: une  partie au niveau de "arboresence de sources"
 % et une partie au niveau de l'API
  % Documentation
  % API non stable
  % generer
  %    pages de man
  %    html
  % sur le web
  %    kernel/doc
  %    lxr.linux.no
  % par mail
  %   connaitre avoir l'auteur avec AUTOR
  %   connaitre l'auteur avec git blame
\begin{frame}[fragile=singleslide]{La documentation}
  \begin{itemize}
  \item Le noyau n'est pas un modèle de documentation
  \item En  revanche, le système de  développement facilite énormément
    la recherche d'informations
  \item  Le noyau utilise  un script  perl appellé  \c{kernel-doc}. Ce
    script parcours le code à la recherche de syntaxe du même type que
    doxygen.  (Référence: \file{Documentation/kernel-docs.txt})
  \item  Un  commentaire ne  doit  pas ce  substituer  à  un code  pas
    illisible.  Préférez   réécrire  le  code   plutôt  qu'ajouter  un
    commentaire.
  \item Une fonction exportée doit être préfixée par un commentaire la
    décrivant.  Ce commentaire ne doit surtout explique \emph{comment}
    la fonction  marche.  Le commentaire indique  le \emph{quoi}, mais
    surtout le \emph{pourquoi} cette fonction existe.
  \item Ces  commentaires sont  placée avant la  \emph{définition} des
    fonctions.  Les  fonction du noyau  sont souvent définie  dans les
    headers.  Du  coup, les commentaires sont parfois  dans le fichier
    \file{.c} et parfois dans le fichier \file{.h}
  \item  Les commentaires  expliquant le  fonctionnement  général d'un
    framework  doivent être  écrit sous  la forme  d'une documentation
    d'architecture et placée dans \file{Documentation/}
  \item Référence: \file{Documentation/CodingStyle}
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{Trouver de la documentation}
  \begin{itemize} 
  \item Dans \file{Documentation} (en utilisant \cmd{grep})
  \item La cible \c{htmldocs}  permet de compiler les documentation au
    format Docbook (\file{Documentation/DocBook})
  \item ... en particulier  \emph{Linux Device Drivers} et \emph{Linux
      Device  Drivers}. Toutefois, ces  compilations sont  loin d'être
    exaustives
  \item  La cible  \c{mandocs}  permet d'extraire  les différente  API
    invoquée dans les DocBook sous forme de pages de man.
  \item    \url{http://kernel.org/doc}     regroupe    les    diverses
    documentations en ligne
  \item Dans les commentaires du noyau (fichiers \c{.c} ou \c{.h})
  \item  \url{http://lxr.linux.no} offre  une interface  permettant de
    rapidement  chercher des  symboles  et naviguer  dans  le code  du
    noyau.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Trouver de l'aide}
  Demander de l'aide à la communauté
  \begin{itemize}
  \item Le fichier \c{MAINTAINERS} contient la liste des mainteneur de
    chaque sous-système
  \item  Les entrées  commencant par  \texttt{L:} indique  des mailing
    lists
  \item Notons \email{linux-newbie@vger.kernel.org}
  \item \c{MAINTAINERS}  liste aussi les sites  officiel, les fichiers
    de  documentation,  etc...  pour  les  différents sous-projets  du
    noyau
  \item \c{git blame} permet de  savoir qui a modifier la fonctions ou
    les lignes qui  nous intéresse. Cela permet de  s'oreinter vers le
    bon groupe
  \item Référence: \url{http://kernel.org/doc}
  \end{itemize}
\end{frame} 

\begin{frame}[fragile=singleslide]{L'API non-stable}
  \begin{itemize} 
  \item  L'API   non-stable  ne   facilite  pas  la   maintenance  des
    documentations
  \item  De même,  la maintenance  des modules  hors du  noyau demande
    beaucoup d'efforts
  \item  C'est  encore pire  de  maintenir  un  module pour  plusieurs
    versions (driver nvidia par exemple)
  \item En  revanche, l'API non  stable permet des  développement plus
    agiles)
  \item  Lors  qu'un développeur  modifie  une  API,  il doit  patcher
    l'ensemble des driver utilisant l'ancienne API.
  \item  On préfère  souvent  laisser l'ancienne  et  la nouvelle  API
    cohabiter en demandant au mainteners de migrer vers la nouvelle
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{L'API non-stable}
  \begin{itemize} 
  \item Il n'y  a pas de raisons de maintenir  un driver à l'extérieur
    du noyau, sauf les problèmes de licence
  \item  Il peut être  couteux en  temps d'intégré  un module  dans le
    mainsteam. Les  mainteneurs vous demanderons  surement de corriger
    beaucoup de chose.
  \item Il faut  compter 2 à 4 fois le  temps de développement initial
    pour intégrer un module dans le mainstream
  \item Une fois que votre module  est intégré dans le mainstream et a
    passé  la phase  de  staging, il  sera  théoriquement maintenu  et
    supporté pour toujours.
  \item Référence \c{Documentation/stable_api_nonsense.txt}
  \end{itemize} 
\end{frame} 

\begin{frame}[fragile=singleslide]{Gestion des erreurs}
  \begin{itemize} 
  \item La plupart des fonctions retournant des \c{int} retournent une
    valeur négative en cas d'erreur
  \item Les  valeurs retournée correspondent aux  inverses des erreurs
    Posix  définis dans  \file{errno.h} (ie:  \c{-EAGAIN}). 
  \item   Référence:   \emph{errno(3)},   \file{asm/errno-base.h}   et
    \file{asm/errno.h}
  \item  Les  fonctions  renvoyant des  pointeurs  peuvent
    retourner NULL ou des valeurs spéciale en cas d'erreur
  \item Utiliser les macro \c{PTR_ERR}, \c{ERR_PTR} et \c{IS_ERR}
  \item Le segfault n'existe pas  dans le noyau.  Par conséquent, vous
    n'avez pas de garde fou (bon, il  y a bien les Oops, mais ca n'est
    pas garanti)
  \item Référence \file{linux/err.h}
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Gestion des erreurs}
  \begin{itemize} 
  \item Vous devez systèmatiquement gérer les erreur retourner par les
    sous-fonctions  même  si  il  vous semble  impossible  qu'elle  se
    produise.
  \item Certaines pannes  matérielles peuvent amener des comportements
    qui paraissent  impossibles. Facilité le  travaille des débuggueur
    en détectant ce type d'erreur le plus tôt possible
  \item Lorsque vous gérez  une erreur, vous devez \emph{défaire} tout
    ce qui à déjà été fait
  \item Une manière commnue  de gérer les erreur d'initialisation dans
    le noyau est d'utiliser \c{goto}:
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Gérer les erreurs}
    \begin{lstlisting}
ptr = kmalloc(sizeof(device_t));
if (!ptr) {
    ret = -ENOMEM
    goto err_alloc;
}
dev = init(&ptr);
if (dev) {
    ret = -EIO
    goto err_init;
}
return 0;

err_init:
    free(ptr);
err_alloc:
    return ret;
    \end{lstlisting} 
\end{frame} 

\section{Notre premier device}


% Parler de l'historique
%   /dev en statique
%   On resrvait les mino et des major en global
%   Puis plus devices
%   Puis l'usb, le model statique ne tennais plus
%   hotplug, udev et mdev, cf /proc/device et /sys/dev/{char,block}
%   \begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize} 
  \item Le seul moya de  communiquer depuis le userspace vers le noyau
    passe par les appel systèmes.
  \item  Il  s'agit  de placer  les  paramètres  sur  la piler  et  de
    déclencher une  interruption logicielle particulière  (sur x86, il
    s'agit         de          l'interruption         0x80,         ou
    \c{sysenter}/\c{sysexit}).  Ainsi,  le noyau  reprend  la main  et
    effectue  une action  en fonction  des paramètres  stockés  que la
    pile.
  \item Le  premier paramètre correspond au numéro  de l'appel système
    (cf.  \emph{syscalls(2)}, \c{asm/unistd.h}).
  \item Il y a environ 300  appels systèmes dans le noyau. Il est rare
    d'ajouter de nouveau appels système et exeptionnel d'en modifer ou
    d'en supprimer.
  \item  Le  modèle Unix  consiste  à  limiter  le nombre  des  appels
    systèmes et de tout gérer par l'intermédiaire de fichiers.
  \item  Parmis  les  appels  systèmes  associés  aux  fichiers,  nous
    trouvons \c{open}, \c{read},  \c{write}, \c{mmap}, \c{ioctl} (pour
    modifier la configuration du périphérique), etc...
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize} 
  \item Il  existe dans la  norme Unix des fichier  spéciaux, appellés
    \emph{fichier devices}, dont les appels systèmes ne sont pas mappé
    sur des fichiers réels mais sur des fonctions du noyau.
  \item Un fichier  device est associé à deux  nombre, le \emph{major}
    et le \emph{minor}.
  \item On  spécifie ces deux nombres  lors de lors de  la création du
    fichier avec la commande \c{mknod}:
    \begin{lstlisting} 
target% mknod my_device c 253 0
target% ls -l my_device
    \end{lstlisting} 
  \item Il  est possible  de communiquer avec  les fichiers  device en
    utilisant les outils standard
    \begin{lstlisting} 
target% cat my_device
target% echo foo > my_device
    \end{lstlisting} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize} 
  \item Coté noyau, un driver  peut allouer une(des) entrée(s) dans la
    table  des  device et  associé  des  fonctions  au appels  système
    associé     à    cette    entrée     (cf.     \c{register_chrdev},
    \c{struct file_operations} dans \c{linux/fs.h})
  \item  En standard, tous  les fichiers  devices sont  regroupés dans
    \file{/dev}.
  \item  Autrefois,  les  numéro  de devices  étaient  normalisés  (cf
    \file{Documentation/devices.txt})  et les fichiers  de \file{/dev}
    était créés statiquement
  \item Avec  l'augmentation du  nombre de périphériques  existants et
    l'arrivé des bus  hotplugs tels que l'USB, ce  modèle n'était plus
    tenable.  Il existe  donc  des système  d'allocation dynamique  de
    numéro     de      devices     (cf.     \file{/proc/device}     et
    \c{/sys/dev/\{char,block\}})     et    des     systèmes    créeant
    automatiquement  les fichiers  nécessaires  (hotplug, udev,  mdev,
    devtmpfs, etc...)
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  \begin{itemize} 
  \item Il existe historiquement deux types de fichiers devices:
    \begin{itemize}
    \item  block: Pour  les  périphériques de  tailles  fixes à  accès
      aléatoire. Principalement des périphériques de stockage.
    \item  character: Pour  les  périphériques avec  des données  sous
      forme de flux comme des ports séries.
    \end{itemize} 
  \item Cette différence est aujourd'hui de moins en moins évidente
  \item Les cartes réseaux sont une exception notable de se modèle. Il
    n'existe pas de  fichiers devices pour les cartes  réseau.  Il est
    nécessaire d'utiliser des appels systèmes spécifiques.
  \item Notons  aussi que de nos jours,  de nombreuses fonctionnalités
    sont  accessibles  par  les  file  systems  virtuels  (\c{procfs},
    \c{sysfs},   \c{debugfs},  etc...).   Ils   permettent  les   même
    fonctionnalité que les fichier devices, mais sans leur complexité.
  \end{itemize} 
\end{frame}

\begin{frame}[fragile=singleslide]{Mémoire userspace}
  Les fonction de la \c{struct file_operations} recoivent en paramètre
  des  addresses  provenant   de  l'espace  d'addressge  du  processus
  appellant. En  raison de la  séparation des espaces mémoire  (nous y
  reviondrons lorsque  nous parlerons plus en  détail du fonctionnment
  de la MMU), c'est addresses  ne peuvent pas être utiliée directement
  dans  le  noyau. Il  est  est  nécessaire  d'utiliser les  fonctions
  \verb+copy_from_user+ et \verb+copy_to_user+ pour y accèder.
\end{frame}
  
%%%%%%%%% 

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
  Nous allons faire un driver permettant de faire un pipe avec un buffer:
  \begin{lstlisting}
target% insmod my_chardev.ko
target% echo toto > my_dhardev
target% cat my_chardev
toto
  \end{lstlisting}
%% TODO: Présenter les différentes fonction ci-dessous
\note{Motrer le code, décrire le contenu}
  Nous utiliserons:
  \begin{itemize}
  \item \verb+copy_to_user+, \verb+copy_from_user+
  \item \verb+kcalloc+, \verb+kfree+
  \item \verb+register_chrdev+, \verb+unregister_chrdev_region+
  %\item   \verb+mutex_lock+,  \verb+mutex_unlock+,  \verb+mutex_init+,
  %  \verb+mutex_destroy+
  \item \verb+memmove+
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]{Communiquer avec le noyau}{char\_dev}
   Vérifions le comportement:
   \begin{lstlisting}
target% insmod my_chrdev.ko
target% mknod my_chrdev c 251 0
target$ for i in {1..64}; echo "$i " > my_chrdev
target$ cat my_chrdev
target% rmmod my_chrdev
    \end{lstlisting} % $
\end{frame}
 
%%% Ajouter ici une demo avec le sioctl. Un ioctl qui renvoye le nombre de byte restant à lire dans le buffer.

% \begin{frame}{Les ioctls}
%   C'est un appel système qui permet de faire passer une structure
%   quelconque à un device.\\
%   Pour appeller un ioctl, il faut un device, le numéro de l'IOCTL et
%   l'arguments.\\
%   Les  numéro d'IOCTL  se  décode ainsi  (attention,  ca n'est  qu'une
%   norme, et elle a ses exeception, principalement powerpc):
% %   \begin{lstlisting}
% %  bits    meaning
% %  31-30  00 - no parameters: uses _IO macro
% %         10 - read: _IOR
% %         01 - write: _IOW
% %         11 - read/write: _IOWR
% % 
% %  29-16  size of arguments
% % 
% %  15-8   ascii character supposedly
% %         unique to each driver
% % 
% %  7-0    function #
% % 
% % 
% % So for example 0x82187201 is a read with arg length of 0x218,
% % character 'r' function 1. Grepping the source reveals this is:
% % Les ioctl doivent être unique par device. Mais on préfère qu'il soit unique
% % sur tout le système.
% % 
% % Les macro _IOR, _IOW, _IORW et _IO nous aident:
% % #define CHANGE_BUF_SZ _IOR(42, 1, int)
% %    \end{lstlisting}

% Aller plus loin: \file{device.h}: Implémentation d'un device complet.
% \end{frame}


  % Programmer
  %   la libc
  %   Big Endian/Little Endian
  %   Preemption (nous y reviendrons)
  %   Les espace mémoire : copy_to_user copy_from_user
  %   Segfault: n'existe pas
  %    Les types: 
  %      u8...u64, s8...s64
  %      __le16..__le64 __be16..__be64
  %      void* et unsigned long et phys_addr_t
 %       linux/types.h
  %      bool mais pas utilisé
  %      Les types de la libc, utilisé pour communique avec l'espace utilisateur: pid_t, uid_t, etc...
  % Les fichier device
  %   mknod
  %   devtmpfs
  % Les appels systèmes
  % Les structure de pointeurs sur fonctions



